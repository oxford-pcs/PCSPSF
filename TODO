
AIRY SCALING F:
------

      
    def getAmplitudeScaledByAiryDiameters(self, n_airy_diameters, power=False, shift=False, normalise=False, scale="linear", verbose=False):
      '''
        Returns a scaled image with only [n_airy_diameters] shown. Useful for plotting.
        
        Returns data and scaled HFOV of the detector.
      '''
      im_npix       = int(np.ceil(self.pupil.gamma*2.44*n_airy_diameters))  # limit the number of pixels in the image
      extent_scale_factor  = float(self.pupil.gsize)/im_npix      # corresponding scale factor to scale extent
      detector_HFOV_scaled   = (self.getDetectorHFOV())/extent_scale_factor    # HFOV of detector, scaled down by [scale]   
      if verbose:
        self.pupil.logger.debug(" Using innermost " + str(im_npix) + " pixels, giving a detector scaled HFOV of " + str(detector_HFOV_scaled) + "\".")

      return self.getAmplitude(power, shift, normalise, scale)[(self.pupil.gsize/2)-(im_npix/2):(self.pupil.gsize/2)+(im_npix/2), (self.pupil.gsize/2)-(im_npix/2):(self.pupil.gsize/2)+(im_npix/2)], detector_HFOV_scaled


OUTPUT
------------


    s.datacube.resampleAndCrop(cfg['OUTPUT_RESAMPLING_FACTOR'], cfg['OUTPUT_HFOV'])


AND


  def resampleAndCrop(self, resampling_factor, hfov):
    '''
      Resample datacube to a given "/px.
    '''
    sampling_pre_rebin 		= self.pscale					# current "/px
    hfov_pre_rebin		= self.hfov
    sampling_post_rebin 	= self.resolution_element/resampling_factor	# desired "/px
    hfov_post_rebin		= hfov
    
    self.logger.debug(" Resampling data.")
    data = []
    for d in self.data:
      data.append(resample2d(d, -hfov_pre_rebin, hfov_pre_rebin, sampling_pre_rebin, -hfov_post_rebin, hfov_post_rebin, sampling_post_rebin))
    self.data = np.array(data)    
    
    self.pscale = sampling_post_rebin
    self.hfov	= hfov_post_rebin




    header.append(('CRVAL1', -self.hfov))
    header.append(('CDELT1', self.pscale))
    header.append(('CRPIX1', 0.5))
    header.append(('CUNIT1', "arcsec"))
    header.append(('CTYPE1', "PARAM"))
    header.append(('CRVAL2', -self.hfov))
    header.append(('CDELT2', self.pscale))
    header.append(('CRPIX2', 0.5))
    header.append(('CUNIT2', "arcsec"))
    header.append(('CTYPE2', "PARAM"))  
    #header.append(('RESAMPTO', str(cfg['RESAMPLE_TO']), 'wavelength at which images are rescaled to (m)'))
    #header.append(('SWIDTH', cfg['SLICE_WIDTH'], 'slice width (resolution units)'))
    #header.append(('HFOV', cfg['HFOV'], 'spatial HFOV (arcsec)'))
    #header.append(('PREFWAV', cfg['PUPIL_REFERENCE_WAVELENGTH'], 'wavelength at which pup. size is determined (m)'))
    #header.append(('PSAMPLE', cfg['PUPIL_SAMPLING'], 'pupil sampling grid size (px)'))
    #header.append(('PGAMMA', cfg['PUPIL_GAMMA'], 'factor by which pupil grid is padded'))
    #header.append(('RESAMPFA', cfg['RESAMPLING_FACTOR'], 'factor by which output is scaled'))
    #header.append(('SLENGTH', float(sf(p['GENERAL']['SLICE_LENGTH'], 4)), 'slice length (mm)'))
    #header.append(('ISLENGTH', float(sf(p['GENERAL']['INTER_SLICE_LENGTH'], 4)), 'inter-slice length (mm)'))
    #header.append(('SSTAGGER', float(sf(p['GENERAL']['SLICE_STAGGER'], 4)), 'slice stagger (mm)'))
    #header.append(('WAVESTA', p['GENERAL']['WAVELENGTH_START'], 'wavelength start (m)'))
    #header.append(('WAVEEND', p['GENERAL']['WAVELENGTH_END'], 'wavelength end (m)'))
    #header.append(('WAVEINT', p['GENERAL']['WAVELENGTH_INTERVAL'], 'wavelength interval (m)'))
    #header.append(('CAMPATH', ntpath.basename(p['GENERAL']['CAMERA_LENS_PATH']), 'camera lens file'))
    #header.append(('COLPATH', ntpath.basename(p['GENERAL']['COLLIMATOR_LENS_PATH']), 'collimator lens file'))
    #header.append(('CAMCONF', p['GENERAL']['CON_CAMERA'], 'camera lens configuration enumeration'))
    #header.append(('COLCONF', p['GENERAL']['CON_COLLIMATOR'], 'collimator lens configuration enumeration'))
    #header.append(('WFESAMP', p['GENERAL']['WFE_SAMPLING'], 'Zemax WFE sampling enumeration'))
    #header.append(('SEARCHD', p['GENERAL']['SEARCH_DIRECTORY'], 'file search directory'))
    #header.append(('CAMEFFL', p['GENERAL']['CAMERA_EFFL'], 'camera EFFL (mm)'))
    #header.append(('CAMWFNO', p['GENERAL']['CAMERA_WFNO'], 'camera WFNO'))
    #header.append(('EPD', p['GENERAL']['EPD'], 'entrance pupil diameter (mm)'))
    #header.append(('NSLICES', p['GENERAL']['NSLICES'], 'number of slices'))
    #header.append(('DETPITCH', str(args.d), 'detector pixel pitch (m)'))
    #header.append(('HASCOWFE', args.cow, 'has collimator WFE been added?'))
    #header.append(('HASCAWFE', args.caw, 'has camera WFE been added?'))
    #for k, v in xtra_header_keys.iteritems():
    #  header.append((k, v[0], v[1]))

PHASE ERRORS
------------

      # Add phase error
      #
      # COLLIMATOR
      #
      if self.ADD_COL_WFE:
	this_wfe_file = None
	for wfe in self.COL_WFE_DATA:
	  if wave == Decimal(str(wfe['WAVE'])) and s.slice_number == wfe['SLICE_INDEX']:
	    this_wfe_file = wfe['PATH']
	    self.logger.debug(" Using collimator WFE map from file " + this_wfe_file)
	if this_wfe_file == None:
	  self.logger.critical(" Didn't find suitable WFE map!")
	  exit(0)	  
	wfe = zwfe(this_wfe_file, self.logger, verbose=verbose)
	wfe.parse()
	wfe_h = wfe.getHeader()	
	wfe_d = wfe.getData(match=pupil, wfe_pd=self.EPD, in_radians=True)		# entrance pupil
	new_pupil.convolve(wfe_d)
	plt_title_prefix = "added phase error "
	self.logger.debug(" Added collimator phase error for slice " + str(s.slice_number) + ".")
      else:
	plt_title_prefix = ""
        
      # CAMERA  
      #
      if self.ADD_CAM_WFE:
	this_wfe_file = None
	for wfe in self.CAM_WFE_DATA:
	  if wave == Decimal(str(wfe['WAVE'])) and s.slice_number == wfe['SLICE_INDEX']:
	    this_wfe_file = wfe['PATH']
	    self.logger.debug(" Using camera WFE map from file " + this_wfe_file)
	if this_wfe_file == None:
	  self.logger.critical(" Didn't find suitable WFE map!")
	  exit(0)	  
	wfe = zwfe(this_wfe_file, self.logger, verbose=verbose)
	wfe.parse()
	wfe_h = wfe.getHeader()	
	wfe_d = wfe.getData(match=pupil, wfe_pd=self.EPD, in_radians=True)		# entrance pupil

	new_pupil.convolve(wfe_d)
	plt_title_prefix = "added phase error "
	self.logger.debug(" Added camera phase error for slice " + str(s.slice_number) + ".")
      else:
	plt_title_prefix = ""
  
        
    return this_composite_image
